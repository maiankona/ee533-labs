# -*- coding: utf-8 -*-
"""arm2custom.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mTJCXqYZPXT7BnPro9BWzifrqgzZr88D
"""

#!/usr/bin/env python3
import re
import sys

# ============================
# REGISTER MAP (32 registers)
# ============================
REG_MAP = {f'r{i}': i for i in range(32)}
#REG_MAP[0] = 0
REG_MAP.update({'sp': 13, 'lr': 14, 'pc': 15, 'fp': 11}) #r10 and r0 are also reserved regs

def get_reg(x): # WORKS
    if not x: return 0
    x = x.lower().strip('[]!, ')
    if x in REG_MAP: return REG_MAP[x]
    m = re.search(r"r(\d+)", x)
    return int(m.group(1)) & 0x1F if m else 0

OPCODES = {
    'ADD': 0b0000, 'SUB': 0b0001, 'AND': 0b0010, 'OR': 0b0011,
    'SLL': 0b0100, 'SRL': 0b0101, 'XOR': 0b1010,
    'RSB': 0b1101, 'MVN': 0b1110, 'CMP': 0b0001
}

def encode(WMemEn, WRegEn, Reg1, Reg2, WReg, alu, ALUSrc, Branch, BrType, imm): #WORKS
    """Encode single instruction"""
    word = 0
    # Override WRegEn if WReg is r0
    actual_WRegEn = WRegEn & 1 # ensure it's 0 or 1
    if WReg == 0:
        actual_WRegEn = 0 # r0 cannot be written to

    word |= (WMemEn & 1) << 31
    word |= (actual_WRegEn) << 30 # Use actual_WRegEn here
    word |= (Reg1 & 0x1F) << 25
    word |= (Reg2 & 0x1F) << 20
    word |= (WReg & 0x1F) << 15
    word |= (alu  & 0xF) << 11
    word |= (ALUSrc & 1) << 10
    word |= (Branch & 1) << 9
    word |= (BrType & 1) << 8
    imm_val = int(imm) & 0xFF
    word |= imm_val
    return word

def get_imm(x): #WORKS
    if not x: return 0
    x = x.replace('#', '').replace('0x', '').strip()
    try:
        val = int(x, 16) if 'x' in x.lower() else int(x) # converts immediate to standard python integer
    except:
        val = 0 # shouldnt be unable to convert an immediate
    return val

def encode_large_immediate(dest_reg, value, instructions):
    """
    Encode large immediate by breaking into multiple instructions.
    For value > 255, use multiple ADDs or shifts.
    Returns the number of instructions generated.
    """
    generated_count = 0

    # if -128 <= value <= 255:
    #     # Fits in 8 bits
    #     if value < 0:
    #         value = (256 + value) & 0xFF
    #     instructions.append(encode(0, 1, 0, 0, dest_reg, OPCODES['ADD'], 1, 0, 0, value))
    #     generated_count += 1
    #     return generated_count

    # For values > 255, break down:
    # Strategy: Build up value in steps
    if 0 <= value <= 65535:
        # Use LSL approach: load lower byte, shift, add upper byte
        low_byte = value & 0xFF
        high_byte = (value >> 8) & 0xFF

        if high_byte > 0:
            # Load high byte
            instructions.append(encode(0, 1, 0, 0, dest_reg, OPCODES['ADD'], 1, 0, 0, high_byte))
            generated_count += 1
            # Shift left by 8 (using LSL with shift=8)
            instructions.append(encode(0, 1, dest_reg, 0, dest_reg, OPCODES['SLL'], 1, 0, 0, 8))
            generated_count += 1
            # Add low byte
            if low_byte > 0:
                instructions.append(encode(0, 1, dest_reg, 0, dest_reg, OPCODES['ADD'], 1, 0, 0, low_byte))
                generated_count += 1
        else:
            # Only low byte, value is 0-255
            instructions.append(encode(0, 1, 0, 0, dest_reg, OPCODES['ADD'], 1, 0, 0, low_byte))
            generated_count += 1
    else:
        # Fallback: just use modulo 256 for larger values, generating 1 instruction
        instructions.append(encode(0, 1, 0, 0, dest_reg, OPCODES['ADD'], 1, 0, 0, value & 0xFF))
        generated_count += 1

    return generated_count

def parse_line(line): # WORKS
    line = re.sub(r'@.*', '', line).strip()
    if not line or line.startswith('.') or line.endswith(':'): return None
    tokens = []
    current = ""
    in_brackets = False
    for char in line:
        if char == '[':
            in_brackets = True
            current += char
        elif char == ']':
            in_brackets = False
            current += char
        elif char in ' \t,' and not in_brackets:
            if current:
                tokens.append(current)
                current = ""
        else:
            current += char
    if current:
        tokens.append(current)
    return tokens if tokens else None

def translate(tokens, current_addr, label_map, instructions):
    """
    Translate one ARM instruction into one or more custom instructions.
    Returns number of instructions generated.
    """
    instr = tokens[0].upper()
    ops = tokens[1:] if len(tokens) > 1 else [] # should never have only instruction word so else doesnt matter

    count = 0

    # ============ PUSH {fp} ============ not necessary since we manually load data in the beginning
    if instr == 'PUSH':
        # str fp, [sp, #-4]
        #instructions.append(encode(0, 1, 13, 11, 0, OPCODES['SUB'], 1, 0, 0, 4))
        #count += 1
        return count

    # ============ DATA PROCESSING ============
    if instr in ['ADD', 'SUB', 'AND', 'ORR', 'EOR', 'RSB']:
        WReg = get_reg(ops[0]) # ops[0] if first input after instr word aka destination register

        if len(ops) == 2: # for data processing should always have 3 ops
            Reg1 = WReg
            src = ops[1]
        else:
            Reg1 = get_reg(ops[1])
            src = ops[2] if len(ops) > 2 else ops[1] # source register aka last input

        op_map = {'ORR': 'OR', 'EOR': 'XOR'} # lowk uneccssary theres no orr or eor in assembly
        alu = OPCODES.get(op_map.get(instr, instr), 0) # normalization of opcode names and retrieving 4 bit alu opcodes
        # should never default to 0

        if '#' in src: # denotes immediate
            imm_val = get_imm(src)
            if -128 <= imm_val <= 255: # can fit within 8 bits we have set for immediate
                imm = imm_val & 0xFF # modulo 256 for positives, 2's complement for negatives
                instructions.append(encode(0, 1, Reg1, 0, WReg, alu, 1, 0, 0, imm))
                # Wmem_en =0, Wreg_en =1, reg1=reg1 (reading from), reg2 (n/a, default 0), WReg=wreg, aluop=alu, alusrc (use imm)=1, no branches, imm
                count += 1
            else:
                # Large immediate - use temp register r10
                generated_imm_count = encode_large_immediate(10, imm_val, instructions)
                count += generated_imm_count
                # Now do operation with temp register
                instructions.append(encode(0, 1, Reg1, 10, WReg, alu, 0, 0, 0, 0)) # final custom opcode
                count += 1
        else:
            Reg2 = get_reg(src)
            instructions.append(encode(0, 1, Reg1, Reg2, WReg, alu, 0, 0, 0, 0))
            count += 1
        return count

    # ============ MOV / MVN ============
    elif instr in ['MOV', 'MVN']:
        WReg = get_reg(ops[0])
        alu = OPCODES['ADD'] if instr == 'MOV' else OPCODES['MVN']

        if len(ops) > 1:
            src = ops[1]
            if '#' in src:
                imm_val = get_imm(src)
                if -128 <= imm_val <= 255:
                    imm = imm_val & 0xFF
                    instructions.append(encode(0, 1, 0, 0, WReg, alu, 1, 0, 0, imm))
                    count += 1
                else:
                    # Large immediate
                    generated_imm_count = encode_large_immediate(WReg, imm_val, instructions)
                    count += generated_imm_count
            else:
                Reg1 = get_reg(src)
                instructions.append(encode(0, 1, Reg1, 0, WReg, alu, 0, 0, 0, 0))
                count += 1
        return count

    # ============ CMP ============
    elif instr == 'CMP':
        Reg1 = get_reg(ops[0])
        if len(ops) > 1:
            src = ops[1]
            if '#' in src:
                imm = get_imm(src) & 0xFF
                instructions.append(encode(0, 0, Reg1, 0, 0, OPCODES['CMP'], 1, 0, 0, imm))
            else:
                Reg2 = get_reg(src)
                instructions.append(encode(0, 0, Reg1, Reg2, 0, OPCODES['CMP'], 0, 0, 0, 0))
        count += 1
        return count

    # ============ LDR ============
    elif instr == 'LDR':
        WReg = get_reg(ops[0])

        if '[' in ops[1]: # LDR rX, [base, #offset]
            base_match = re.search(r'\[([^\]:,]+)', ops[1])
            if base_match:
                Reg1 = get_reg(base_match.group(1))

            offset = 0
            offset_match = re.search(r'#(-?\d+)', ops[1])
            if offset_match:
                offset = get_imm(offset_match.group(1))

            # Handle signed offset
            if offset < 0:
                offset = (256 + offset) & 0xFF

            if offset <= 255:
                instructions.append(encode(1, 1, Reg1, 0, WReg, OPCODES['ADD'], 1, 0, 0, offset))
                count += 1
            else:
                # Large offset - compute address in temp register
                generated_imm_count = encode_large_immediate(10, offset, instructions)
                count += generated_imm_count
                # The LDR for large offset scenario is: calculate address into temp (r10), then LDR from temp to WReg
                instructions.append(encode(0, 1, Reg1, 10, 10, OPCODES['ADD'], 0, 0, 0, 0)) # Calculate effective address into r10
                instructions.append(encode(1, 1, 10, 0, WReg, OPCODES['ADD'], 1, 0, 0, 0)) # LDR from r10 to WReg
                count += 2

        else: # LDR rX, .Llabel (literal pool)
            target_operand = ops[1].strip()
            target_label_match = re.match(r'^(\.[a-zA-Z0-9_]+)(?:\+(\d+))?$', target_operand)
            if target_label_match: # Ensure it's a literal pool label, possibly with offset
                base_label = target_label_match.group(1)
                additional_offset = int(target_label_match.group(2)) if target_label_match.group(2) else 0

                if base_label in label_map:
                    # Calculate offset from PC to the address of base_label, then add additional_offset
                    # PC is usually current_addr + 1 instruction (since it's fetched before exec)
                    base_addr = label_map[base_label]
                    effective_target_addr = base_addr + additional_offset

                    offset = (effective_target_addr - (current_addr + 1)) & 0xFF

                    # Now, encode LDR using PC (r15) as the base register and the calculated offset
                    instructions.append(encode(1, 1, 15, 0, WReg, OPCODES['ADD'], 1, 0, 0, offset))
                    count += 1
                else:
                    # Label not found (shouldn't happen in pass 2 if Pass 1 is correct)
                    instructions.append(encode(0, 1, 0, 0, WReg, OPCODES['ADD'], 1, 0, 0, 0))
                    count += 1
            else:
                # Fallback for unexpected LDR format without brackets and not a literal pool
                instructions.append(encode(0, 1, 0, 0, WReg, OPCODES['ADD'], 1, 0, 0, 0))
                count += 1

        return count

    # ============ STR ============
    elif instr == 'STR':
        # Reg2 is the DATA we want to store
        Reg2 = get_reg(ops[0])

        # Check for post-indexed addressing '!'
        post_indexed_writeback = False
        if ops[1].endswith('!'):
            post_indexed_writeback = True
            # Remove '!' for parsing the address part
            address_operand = ops[1].rstrip('!')
        else:
            address_operand = ops[1]

        if '[' in address_operand:
            base_match = re.search(r'\[([^\]:,]+)', address_operand)
            if base_match:
                Reg1 = get_reg(base_match.group(1)) # Base Address

            offset = 0
            offset_match = re.search(r'#(-?\d+)', address_operand)
            if offset_match:
                offset = get_imm(offset_match.group(1))
            elif len(ops) > 2:
                # Fallback for STR rX, [base], #offset (post-indexed without !) which is not really supported here
                offset_match = re.search(r'#(-?\d+)', ops[2])
                if offset_match:
                    offset = get_imm(offset_match.group(1))

            if offset < 0:
                offset = (256 + offset) & 0xFF

            # First, the actual store operation
            instructions.append(encode(1, 0, Reg1, Reg2, 0, OPCODES['ADD'], 1, 0, 0, offset))
            count += 1

            # If post-indexed with writeback (!), also update the base register
            if post_indexed_writeback:
                # The instruction to update the base register is a SUB operation for negative offsets
                # or ADD for positive. Here, #-4 means SUB.
                instructions.append(encode(0, 1, Reg1, 0, Reg1, OPCODES['SUB'], 1, 0, 0, get_imm(address_operand.split('#')[1])))
                count += 1

        return count

    # ============ LSL ============
    elif instr == 'LSL':
        WReg = get_reg(ops[0])
        Reg1 = get_reg(ops[1]) if len(ops) > 1 else WReg # unnecessary check
        shift_amt = get_imm(ops[-1]) & 0x1F

        instructions.append(encode(0, 1, Reg1, 0, WReg, OPCODES['SLL'], 1, 0, 0, shift_amt))
        count += 1
        return count

    # ============ BRANCHES ============
    elif instr in ['B', 'BEQ', 'BNE', 'BLT', 'BLE', 'BGT', 'BGE']:
        target_label = ops[0]
        if target_label in label_map: # should always be in label map tbh...
            # Calculate offset for the first instruction
            offset_initial = label_map[target_label] - (current_addr + 1)
            imm_initial = offset_initial & 0xFF
        else:
            imm_initial = 0 # Default to 0 if label not found (shouldn't happen in pass 2)

        if instr == 'BLE':
            # Generate BEQ instruction
            instructions.append(encode(0, 0, 0, 0, 0, 0, 1, 1, 0, imm_initial)) # BrType 0 for BEQ
            count += 1

            # Calculate offset for the second instruction (BLT),
            # relative to the address after the BEQ instruction.
            # current_addr + 1 (for BEQ) + 1 (for BLT)
            if target_label in label_map:
                offset_blt = label_map[target_label] - (current_addr + 2) # +2 because BEQ already took one slot
                imm_blt = offset_blt & 0xFF
            else:
                imm_blt = 0 # Default to 0

            # Generate BLT instruction
            instructions.append(encode(0, 0, 0, 0, 0, 0, 1, 1, 1, imm_blt)) # BrType 1 for BLT
            count += 1
        else:
            # Existing logic for other branches
            BrType = 0 if instr in ['B', 'BEQ', 'BNE'] else 1
            instructions.append(encode(0, 0, 0, 0, 0, 0, 1, 1, BrType, imm_initial))
            count += 1
        return count

    # Unknown instruction - skip
    return 0

def main():
    infile = sys.argv[1]
    with open(infile, 'r') as f:
        lines = f.readlines()

    # Pass 1: Build label map (need to account for multi-instruction expansions)
        label_map = {}
    addr = 0
    for line in lines:
        raw = line.strip()
        if not raw or raw.startswith('@'): # ignores comments
            continue
        if raw.startswith('.') and not raw.endswith(':'): # ignores non branches
            continue
        if raw.endswith(':'): # branches L2, L3, etc.
            label_map[raw[:-1]] = addr # stores address starting from 0 in map
        else:
            tokens = parse_line(raw) # WORKS
            if tokens: # if its a valid instruction
                current_line_instr_count = 1 # Default for most instructions
                instr = tokens[0].upper()

                if instr == 'MOV' and len(tokens) > 1 and '#' in tokens[-1]:
                    val = get_imm(tokens[-1])
                    dest_reg = get_reg(tokens[1]) # Get destination register to check if it's r0

                    if dest_reg == 0: # If MOV destination is r0, it's effectively a NOP
                        current_line_instr_count = 0
                    elif 0 <= val <= 255:
                        current_line_instr_count = 1
                    elif 256 <= val <= 65535:
                        low_byte = val & 0xFF
                        high_byte = (val >> 8) & 0xFF
                        if high_byte > 0:
                            if low_byte > 0:
                                current_line_instr_count = 3
                            else:
                                current_line_instr_count = 2
                    else: # val > 65535, encode_large_immediate's fallback path
                        current_line_instr_count = 1
                elif instr == 'PUSH':
                    current_line_instr_count = 0
                elif instr == 'BLE':
                    current_line_instr_count = 2
                elif instr == 'STR' and len(tokens) > 1 and tokens[1].endswith('!'):
                    # STR with writeback generates 2 instructions (STR + SUB/ADD)
                    current_line_instr_count = 2

                addr += current_line_instr_count

    print(f"Label map: {label_map}") # works and maps branches correctly

    # Pass 2: Translate with multi-instruction support
    all_instructions = []
    addr = 0 # restart addy
    assembly_lines = []

    for line in lines:
        tokens = parse_line(line)
        if tokens: # getting an actual instr
            count = translate(tokens, addr, label_map, all_instructions)
            for i in range(count):
                assembly_lines.append((' '.join(tokens), addr + i))
            addr += count

    # Write output
    outfile = infile.replace('.s', '_custom.txt')
    with open(outfile, 'w') as out_f:
        for i, code in enumerate(all_instructions):
            asm_line = ""
            for line, line_addr in assembly_lines:
                if line_addr == i:
                    asm_line = line
                    break
            output_str = f"{i:03x}: {code:08x}  |  {asm_line}"
            print(output_str)
            out_f.write(f"{code:08x}\n")

    print(f"\nWrote {len(all_instructions)} instructions to {outfile}")

if __name__ == "__main__":
    main()
